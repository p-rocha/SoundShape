#find_rtools()
#devtools::install_github("p-rocha/SoundShape")
# Clear environment prior to package
rm(list=ls())
# Define working directory where package will be created
setwd("C:/R")
# Create folder where package will be stored
#create("SoundShape")
# Process documentation (each function edited manually)
document("C:/R/SoundShape")
# Install package directly
install("C:/R/SoundShape")
# Build package
build("C:/R/SoundShape")
library(seewave)
library(tuneR)
# Create temporary folder to store ".wav" files
wav.at <- file.path(base::tempdir(), "eig.sample")
if(!dir.exists(wav.at)) dir.create(wav.at)
# Create temporary folder to store results
store.at <- file.path(base::tempdir(), "eig.sample-output")
if(!dir.exists(store.at)) dir.create(store.at)
# Select three acoustic units within each sound data
data(cuvieri)
spectro(cuvieri, flim = c(0,4))
cut.cuvieri1 <- cutw(cuvieri, f=44100, from=0, to=0.5, output = "Wave")
cut.cuvieri2 <- cutw(cuvieri, f=44100, from=0.7, to=1.2, output = "Wave")
cut.cuvieri3 <- cutw(cuvieri, f=44100, from=1.4, to=1.9, output = "Wave")
data("centralis")
spectro(centralis, flim = c(0,4))
cut.centralis1 <- cutw(centralis, f=44100, from=0.1, to=0.8, output = "Wave")
cut.centralis2 <- cutw(centralis, f=44100, from=1.05, to=1.75, output = "Wave")
cut.centralis3 <- cutw(centralis, f=44100, from=2.1, to=2.8, output = "Wave")
data("kroyeri")
spectro(kroyeri, flim = c(0,4))
cut.kroyeri1 <- cutw(kroyeri, f=44100, from=0.1, to=1, output = "Wave")
cut.kroyeri2 <- cutw(kroyeri, f=44100, from=1.5, to=2.3, output = "Wave")
cut.kroyeri3 <- cutw(kroyeri, f=44100, from=2.9, to=3.8, output = "Wave")
# Export new wave files containing acoustic units and store on previosly created folder
writeWave(cut.cuvieri1, filename = file.path(wav.at, "cut.cuvieri1.wav"), extensible = FALSE)
writeWave(cut.cuvieri2, filename = file.path(wav.at, "cut.cuvieri2.wav"), extensible = FALSE)
writeWave(cut.cuvieri3, filename = file.path(wav.at, "cut.cuvieri3.wav"), extensible = FALSE)
writeWave(cut.centralis1, filename = file.path(wav.at, "cut.centralis1.wav"), extensible = FALSE)
writeWave(cut.centralis2, filename = file.path(wav.at, "cut.centralis2.wav"), extensible = FALSE)
writeWave(cut.centralis3, filename = file.path(wav.at, "cut.centralis3.wav"), extensible = FALSE)
writeWave(cut.kroyeri1, filename = file.path(wav.at, "cut.kroyeri1.wav"), extensible = FALSE)
writeWave(cut.kroyeri2, filename = file.path(wav.at, "cut.kroyeri2.wav"), extensible = FALSE)
writeWave(cut.kroyeri3, filename = file.path(wav.at, "cut.kroyeri3.wav"), extensible = FALSE)
# Place sounds at beggining of sound window before analysis
align.wave(wav.at = wav.at, wav.to = "Aligned",
time.length = 0.8, time.perc = 0.005, dBlevel = 25)
# Verify alignment using analysis.type = "twoDshape"
eigensound(analysis.type = "twoDshape", wav.at = file.path(wav.at, "Aligned"),
store.at = store.at, flim=c(0, 4), tlim=c(0, 0.8),
plot.exp = TRUE, plot.as = "jpeg", dBlevel = 25)
# Go to folder specified by store.at and check jpeg files created
# Run eigensound function using analysis.type = "threeDshape" on aligned wave files
# Store results as R object
eig.sample <- eigensound(analysis.type="threeDshape", wav.at = file.path(wav.at, "Aligned"),
flim=c(0, 4), tlim=c(0, 0.8), dBlevel=25, plot.exp = FALSE,
x.length=70, y.length = 47, log.scale = TRUE)
wav.at
wav.at <- file.path(base::tempdir(), "eigensound")
if(!dir.exists(wav.at)) dir.create(wav.at)
# Create temporary folder to store results
store.at <- file.path(base::tempdir(), "eigensound-output")
if(!dir.exists(store.at)) dir.create(store.at)
# Cut acoustic units from original Wave
cut.cuvieri <- cutw(cuvieri, f=44100, from=0, to=0.9, output = "Wave")
cut.centralis <- cutw(centralis, f=44100, from=0, to=0.9, output = "Wave")
cut.kroyeri <- cutw(kroyeri, f=44100, from=0.2, to=1.1, output = "Wave")
# Export ".wav" files containing acoustic units and store on previosly created folder
writeWave(cut.cuvieri, filename = file.path(wav.at, "cut.cuvieri.wav"), extensible = FALSE)
writeWave(cut.centralis, filename = file.path(wav.at, "cut.centralis.wav"), extensible = FALSE)
writeWave(cut.kroyeri, filename = file.path(wav.at, "cut.kroyeri.wav"), extensible = FALSE)
\donttest{
# Create 2D spectrograms using analysis.type = "twoDshape"
eigensound(analysis.type = "twoDshape", flim=c(0, 4), tlim=c(0, 0.8),
plot.exp=TRUE, wav.at = wav.at, store.at = store.at)
# Create 3D spectrograms using analysis.type = "threeDshape" and store point coordinates
eig.data <- eigensound(analysis.type = "threeDshape", plot.exp=TRUE,
wav.at = wav.at, store.at = store.at, flim=c(0, 4), tlim=c(0, 0.8))
# As simple as this
threeDspectro(centralis)
threeDspectro(cuvieri)
threeDspectro(kroyeri)
# Controling some arguments
threeDspectro(cuvieri, tlim=c(0, 0.5), flim=c(0, 4))
threeDspectro(cuvieri, tlim=c(0, 0.5), flim=c(0, 4), samp.grid=FALSE)
threeDspectro(cuvieri, tlim=c(0, 0.5), flim=c(0, 4), samp.grid=FALSE, dBlevel=60)
# Try different colors
threeDspectro(cuvieri, color=seewave::reverse.terrain.colors(80),
samp.grid=FALSE, tlim=c(0, 0.5), flim=c(0, 4))
threeDspectro(cuvieri, color=seewave::reverse.cm.colors(80),
samp.grid=FALSE, tlim=c(0, 0.5), flim=c(0, 4))
threeDspectro(cuvieri, color=grDevices::heat.colors(80),
samp.grid=FALSE, tlim=c(0, 0.5), flim=c(0, 4))
# Rotation
threeDspectro(cuvieri, tlim=c(0, 0.5), flim=c(0, 4), rotate.Xaxis=40, rotate.Yaxis=50)
# Export your graph
threeDspectro(cuvieri, plot.exp=TRUE, store.at=tempdir(), tlim=c(0,0.5), flim=c(0,4))
install.packages("EcoHydRology")
?EcoHydRology
??EcoHydRology
?check_built
check_built("C:/R/SoundShape_1.1.9.tar.gz", _R_CHECK_LENGTH_1_LOGIC2_=abort,verbose)
dir()
check_built("C:/R/seewave_2.2.0.zip")
_R_CHECK_LENGTH_1_LOGIC2_=abort,verbose
check_R_CHECK_LENGTH_1_LOGIC2_=abort,verbose
check_built("C:/R/SoundShape_1.1.9.tar.gz", '_R_CHECK_LENGTH_1_LOGIC2_=abort,verbose')
check_built("C:/R/SoundShape_1.1.9.tar.gz", cran='_R_CHECK_LENGTH_1_LOGIC2_=abort,verbose')
check_built("C:/R/SoundShape_1.1.9.tar.gz", build_args='_R_CHECK_LENGTH_1_LOGIC2_=abort,verbose')
check_built("C:/R/SoundShape_1.1.9.tar.gz", build_args_R_CHECK_LENGTH_1_LOGIC2_=abort,verbose)
check_built("C:/R/SoundShape_1.1.9.tar.gz", build_args_R_CHECK_LENGTH_1_LOGIC2_)
Sys.setenv('_R_CHECK_LENGTH_1_LOGIC2_=abort,verbose')
Sys.setenv(_R_CHECK_LENGTH_1_LOGIC2_=abort,verbose)
Sys.setenv('_R_CHECK_LENGTH_1_LOGIC2_'=abort,verbose)
Sys.setenv('_R_CHECK_LENGTH_1_LOGIC2_'='abort,verbose')
?Sys.setenv
# R CMD check
#dir("C:/R", pattern="tar.gz")
check_built("C:/R/SoundShape_1.1.9.tar.gz", run_dont_test=TRUE)
library(roxygen2)
library(devtools)
# Clear environment prior to package
rm(list=ls())
# Define working directory where package will be created
setwd("C:/R")
# R CMD check
#dir("C:/R", pattern="tar.gz")
check_built("C:/R/SoundShape_1.1.9.tar.gz", run_dont_test=TRUE)
# R CMD check
#dir("C:/R", pattern="tar.gz")
check_built("C:/R/SoundShape_1.1.9.tar.gz", run_dont_test=TRUE)
# R CMD check
#dir("C:/R", pattern="tar.gz")
check_built("C:/R/SoundShape_1.1.9.tar.gz")
library(roxygen2)
library(devtools)
#find_rtools()
#devtools::install_github("p-rocha/SoundShape")
# Clear environment prior to package
rm(list=ls())
# Define working directory where package will be created
setwd("C:/R")
# Create folder where package will be stored
#create("SoundShape")
# Process documentation (each function edited manually)
document("C:/R/SoundShape")
# Install package directly
install("C:/R/SoundShape")
# Build package
build("C:/R/SoundShape")
??setenv
library(roxygen2)
library(devtools)
#find_rtools()
#devtools::install_github("p-rocha/SoundShape")
# Clear environment prior to package
rm(list=ls())
# Define working directory where package will be created
setwd("C:/R")
# Create folder where package will be stored
#create("SoundShape")
# Process documentation (each function edited manually)
document("C:/R/SoundShape")
# Install package directly
install("C:/R/SoundShape")
# Build package
build("C:/R/SoundShape")
# R CMD check
#dir("C:/R", pattern="tar.gz")
check_built("C:/R/SoundShape_1.1.9.tar.gz")
library(roxygen2)
library(devtools)
#find_rtools()
#devtools::install_github("p-rocha/SoundShape")
# Clear environment prior to package
rm(list=ls())
# Define working directory where package will be created
setwd("C:/R")
# Create folder where package will be stored
#create("SoundShape")
# Process documentation (each function edited manually)
document("C:/R/SoundShape")
# Install package directly
install("C:/R/SoundShape")
# Build package
build("C:/R/SoundShape")
# R CMD check
#dir("C:/R", pattern="tar.gz")
check_built("C:/R/SoundShape_1.1.9.tar.gz")
library(roxygen2)
library(devtools)
#find_rtools()
#devtools::install_github("p-rocha/SoundShape")
# Clear environment prior to package
rm(list=ls())
# Define working directory where package will be created
setwd("C:/R")
# Create folder where package will be stored
#create("SoundShape")
# Process documentation (each function edited manually)
document("C:/R/SoundShape")
# Install package directly
install("C:/R/SoundShape")
# Build package
build("C:/R/SoundShape")
# R CMD check
#dir("C:/R", pattern="tar.gz")
check_built("C:/R/SoundShape_1.1.9.tar.gz")
library(SoundShape)
library(roxygen2)
library(devtools)
find_rtools()
library(SoundShape)
version(SoundShape)
version("SoundShape")
?`SoundShape-package`
getwd()
cuvieri
library(tuneR)
library(seewave)
writeWave(cuvieri, filename = file.path(getwd(), "cuvieri.wav"), extensible = T)
getwd()
dir(getwd())
setwd("C:/Users/n10832777/OneDrive - Queensland University of Technology/R/SoundShape - Package development")
cuvieri
setwd("C:/Users/n10832777/OneDrive - Queensland University of Technology/R/SoundShape - Package development")
writeWave(centralis, filename = file.path(getwd(), "centralis.wav"), extensible = T)
writeWave(cuvieri, filename = file.path(getwd(), "cuvieri.wav"), extensible = T)
writeWave(kroyeri, filename = file.path(getwd(), "kroyeri.wav"), extensible = T)
# List tables
dir(get.wd(), pattern = "selections.txt")
# List tables
dir(getwd(), pattern = "selections.txt")
# List tables
raven.tables <- dir(getwd(), pattern = "selections.txt")
read.table(raven.tables[1])
read.table(raven.tables[1], h=T, sep="\t")
raven.selections <- data.frame()
raven.temp <- read.table(raven.tables[1], h=T, sep="\t")
rbind(raven.selections, raven.temp)
raven.temp <- read.table(raven.tables[2], h=T, sep="\t")
rbind(raven.selections, raven.temp)
raven.selections <- rbind(raven.selections, raven.temp)
raven.temp <- read.table(raven.tables[3], h=T, sep="\t")
raven.selections <- rbind(raven.selections, raven.temp)
raven.selections
raven.selections <- data.frame()
raven.selections
raven.selections <- data.frame()
for(raven in raven.tables){
raven.temp <- read.table(raven, h=T, sep="\t")
raven.selections <- rbind(raven.selections, raven.temp)
rm(raven.temp)
}
raven.selections$View
raven.selections <- data.frame()
for(raven in raven.tables){
raven.temp <- read.table(raven, h=T, sep="\t", stringsAsFactors = T)
raven.selections <- rbind(raven.selections, raven.temp)
rm(raven.temp)
}
raven.selections$View
raven.selections <- raven.selections[raven.selections$View=="Waveform 1"]
raven.selections <- raven.selections[raven.selections$View=="Waveform 1",]
raven.selections$View
raven.selections <- droplevels(raven.selections[raven.selections$View=="Waveform 1",])
raven.selections$View
raven.selections$Delta.time <- raven.selections$End.Time..s.-
raven.selections$Begin.Time..s.
raven.selections$Delta.time
max(raven.selections$Delta.time)
raven.selections
raven.selections <- data.frame()
for(raven in raven.tables){
raven.temp <- read.table(raven, h=T, sep="\t", stringsAsFactors = T)
raven.selections <- rbind(raven.selections, raven.temp)
rm(raven.temp)
} # end loop
# List tables
raven.tables <- dir(getwd(), pattern = "selections.txt")
raven.selections <- data.frame()
for(raven in raven.tables){
raven.temp <- read.table(raven, h=T, sep="\t", stringsAsFactors = T)
raven.selections <- rbind(raven.selections, raven.temp)
rm(raven.temp)
} # end loop
raven.selections <- data.frame()
for(raven in raven.tables){
raven.temp <- read.table(raven, h=T, sep="\t", stringsAsFactors = T)
raven.selections <- rbind(raven.selections, raven.temp)
rm(raven.temp)
} # end loop
raven.temp
rm(raven.temp)
raven.selections <- data.frame()
for(raven in raven.tables){
raven.temp <- read.table(raven, h=T, sep="\t", stringsAsFactors = T)
raven.selections <- rbind(raven.selections, raven.temp)
rm(raven.temp)
} # end loop
rm(raven.temp)
raven.selections <- data.frame()
for(raven in raven.tables){
raven.temp <- read.table(raven, h=T, sep="\t", stringsAsFactors = T)
raven.selections <- rbind(raven.selections, raven.temp)
rm(raven.temp)
} # end loop
raven.selections <- droplevels(raven.selections[raven.selections$View=="Waveform 1",])
# Use delta time to decide how long the sample wav files need to be
raven.selections$Delta.time <- raven.selections$End.Time..s.-
raven.selections$Begin.Time..s.
max(raven.selections$Delta.time)  # 0.77 s
raven.selections
# Create temporary folder to store ".wav" files
wav.at <- getwd()
wav.at
dir(wav.at)
dir(wav.at, pattern="wav")
# Create temporary folder to store results
store.at <- file.path(get.wd(), "output")
# Create temporary folder to store results
store.at <- file.path(getwd(), "output")
if(!dir.exists(store.at)) dir.create(store.at)
# List of original wav files analysed
wav.files <- dir(pattern="wav")
wav.files
wav.temp <- readWave(wav.files[1])
wav.temp
wav.files[1]
grep(wav.files[1], raven.tables)
library(stringr)
str_sub(wav.files[1],4)
str_sub(wav.files[1],-4)
str_sub(wav.files[1],from=0, to = -4)
?str_sub
?str_sub(wav.files[1],start=0, end = -4)
str_sub(wav.files[1],start=0, end = -4)
grep(str_sub(wav.files[1],start=0, end = -5), raven.tables)
?grep
match(str_sub(wav.files[1],start=0, end = -5), raven.tables)
# Folder where original ".wav" files are saved
wav.at <- getwd()
wav.at
# List of original wav files analysed
wav.files <- dir(pattern="wav")
wav.files
# List of original wav files analysed
wav.files <- dir(pattern="wav")
wav.files
setwd("C:/Users/n10832777/OneDrive - Queensland University of Technology/R/SoundShape - Package development")
# Folder where original ".wav" files are saved
wav.at <- getwd()
# List of original wav files analysed
wav.files <- dir(pattern="wav")
wav.files
# List of raven tables from wav files analysed
raven.tables <- dir(getwd(), pattern = "selections.txt")
raven.tables
wav.temp <- readWave(wav.files[1])
library(tuneR)
library(seewave)
library(stringr)
wav.temp <- readWave(wav.files[1])
wav.temp
grep(wav.files[1], raven.tables, value = T)
grep(wav.files[1], raven.tables)
grep(str_sub(wav.files[1],start=0, end = -5), raven.tables)
grep(str_sub(wav.files[1],start=0, end = -5), raven.tables, value=T)
grep(str_sub(wav.files[2],start=0, end = -5), raven.tables, value=T)
grep(str_sub(wav.files[3],start=0, end = -5), raven.tables, value=T)
raven.file <- grep(str_sub(wav.files[1],start=0, end = -5),
raven.tables, value=T)
read.table(raven.file)
read.table(raven.file, h=T)
read.table(raven.file, h=T, sep="\t")
wav
raven.temp <- read.table(grep(str_sub(wav.files[1],start=0, end = -5),
raven.tables, value=T), h=T, sep="\t")
raven.temp$Selection
raven.temp$Selection[raven.temp$View=="Waveform 1"]
raven.temp$Begin.Time..s.[raven.temp$Selection== 1 & raven.temp$View=="Waveform 1"]
length(raven.temp$Selection[raven.temp$View=="Waveform 1"])
# Create folder to store sample wav files
store.at <- file.path(getwd(), "output")
store.at
if(!dir.exists(store.at)) dir.create(store.at)
max(raven.selections$Delta.time)*0.2
for(raven in raven.tables){
raven.temp <- read.table(raven, h=T, sep="\t", stringsAsFactors = T)
raven.selections <- rbind(raven.selections, raven.temp)
rm(raven.temp)
} # end loop
raven.selections <- data.frame()
for(raven in raven.tables){
raven.temp <- read.table(raven, h=T, sep="\t", stringsAsFactors = T)
raven.selections <- rbind(raven.selections, raven.temp)
rm(raven.temp)
} # end loop
raven.selections <- droplevels(raven.selections[
raven.selections$View=="Waveform 1",])
# Use delta time to decide how long the sample wav files need to be
raven.selections$Delta.time <- raven.selections$End.Time..s.-
raven.selections$Begin.Time..s.
max.dur <- max(raven.selections$Delta.time) +
max(raven.selections$Delta.time)*0.2  # 0.77 s + (20% of 0.77)
max.dur
raven.temp$Begin.Time..s.[
raven.temp$Selection== 1 & raven.temp$View=="Waveform 1"]
raven.temp <- read.table(grep(str_sub(wav.files[1],start=0, end = -5),
raven.tables, value=T), h=T, sep="\t")
raven.temp$Begin.Time..s.[
raven.temp$Selection== 1 & raven.temp$View=="Waveform 1"]
raven.temp$Begin.Time..s.[
raven.temp$Selection== 1 & raven.temp$View=="Waveform 1"]+
max.dur
wav.temp <- readWave(wav.files[1], units="seconds",
from= raven.temp$Begin.Time..s.[
raven.temp$Selection== 1 & raven.temp$View=="Waveform 1"],
to= raven.temp$Begin.Time..s.[
raven.temp$Selection== 1 & raven.temp$View=="Waveform 1"]+
max.dur)
wav.temp
max.dur
store.at
i=1
file.path(store.at, paste(wav.files[1], " - sample ", i, ".wav"))
file.path(store.at, paste(wav.files[1], " - sample ", i, ".wav", sep=""))
file.path(store.at, paste(str_sub(wav.files[1],start=0, end = -5), " - sample ", i, ".wav", sep=""))
rm(list=ls())
library(tuneR)
library(seewave)
library(stringr)
setwd("C:/Users/n10832777/OneDrive - Queensland University of Technology/R/SoundShape - Package development")
# Import Raven tables
raven.selections <- data.frame()
for(raven in raven.tables){
raven.temp <- read.table(raven, h=T, sep="\t", stringsAsFactors = T)
raven.selections <- rbind(raven.selections, raven.temp)
rm(raven.temp)
} # end loop
# List tables
raven.tables <- dir(getwd(), pattern = "selections.txt")
# Import Raven tables
raven.selections <- data.frame()
for(raven in raven.tables){
raven.temp <- read.table(raven, h=T, sep="\t", stringsAsFactors = T)
raven.selections <- rbind(raven.selections, raven.temp)
rm(raven.temp)
} # end loop
# Use delta time to decide how long the sample wav files need to be
# maximum duration = longest call plus 20% of longest duration
raven.selections$Delta.time <- raven.selections$End.Time..s.-
raven.selections$Begin.Time..s.
max.dur <- max(raven.selections$Delta.time) +
max(raven.selections$Delta.time)*0.2  # 0.77 s + (20% of 0.77)
# Folder where original ".wav" files are saved
wav.at <- getwd()
# List of original wav files analysed
wav.files <- dir(pattern="wav")
wav.files
# List of raven tables from wav files analysed
raven.tables <- dir(getwd(), pattern = "selections.txt")
raven.tables
# Create folder to store sample wav files
store.at <- file.path(getwd(), "output")
if(!dir.exists(store.at)) dir.create(store.at) # create if folder doesn't exist
# For each wav file, use Raven selections to create new files
for(wav in wav.files){
raven.temp <- read.table(grep(str_sub(wav.files[1],start=0, end = -5),
raven.tables, value=T), h=T, sep="\t")
for(i in 1:length(raven.temp$Selection[raven.temp$View=="Waveform 1"])){
wav.temp <- readWave(wav.files[1], units="seconds",
from= raven.temp$Begin.Time..s.[
raven.temp$Selection== i & raven.temp$View=="Waveform 1"],
to= raven.temp$Begin.Time..s.[
raven.temp$Selection== i & raven.temp$View=="Waveform 1"]+
max.dur)
writeWave(wav.temp, extensible = T,
filename = file.path(store.at,
paste(str_sub(wav.files[1],start=0, end = -5),
" - sample ", i, ".wav", sep="")))
rm(wav.temp)
} # end loop - for each selection
rm(raven.temp)
} # end loop - for each wav file
# For each wav file, use Raven selections to create new files
for(wav in wav.files){
raven.temp <- read.table(grep(str_sub(wav,start=0, end = -5),
raven.tables, value=T), h=T, sep="\t")
for(i in 1:length(raven.temp$Selection[raven.temp$View=="Waveform 1"])){
wav.temp <- readWave(wav, units="seconds",
from= raven.temp$Begin.Time..s.[
raven.temp$Selection== i & raven.temp$View=="Waveform 1"],
to= raven.temp$Begin.Time..s.[
raven.temp$Selection== i & raven.temp$View=="Waveform 1"]+
max.dur)
writeWave(wav.temp, extensible = T,
filename = file.path(store.at,
paste(str_sub(wav,start=0, end = -5),
" - sample ", i, ".wav", sep="")))
rm(wav.temp)
} # end loop - for each selection
rm(raven.temp)
} # end loop - for each wav file
library(stringr)
library(seewave)
load("C:/Users/n10832777/OneDrive - Queensland University of Technology/08 - Chapter 2 - Biophony/Acoustic indices and SM4 metadata.RData")
setwd("C:/Users/n10832777/OneDrive - Queensland University of Technology/08 - Chapter 2 - Biophony/R output")
