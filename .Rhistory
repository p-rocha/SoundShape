cut.cuvieri3 <- cutw(cuvieri, f=44100, from=1.4, to=1.9, output = "Wave")
data("centralis")
spectro(centralis, flim = c(0,4))
cut.centralis1 <- cutw(centralis, f=44100, from=0.1, to=0.8, output = "Wave")
cut.centralis2 <- cutw(centralis, f=44100, from=1.05, to=1.75, output = "Wave")
cut.centralis3 <- cutw(centralis, f=44100, from=2.1, to=2.8, output = "Wave")
data("kroyeri")
spectro(kroyeri, flim = c(0,4))
cut.kroyeri1 <- cutw(kroyeri, f=44100, from=0.1, to=1, output = "Wave")
cut.kroyeri2 <- cutw(kroyeri, f=44100, from=1.5, to=2.3, output = "Wave")
cut.kroyeri3 <- cutw(kroyeri, f=44100, from=2.9, to=3.8, output = "Wave")
# Export new wave files containing acoustic units and store on previosly created folder
writeWave(cut.cuvieri1, filename = file.path(wav.at, "cut.cuvieri1.wav"), extensible = FALSE)
writeWave(cut.cuvieri2, filename = file.path(wav.at, "cut.cuvieri2.wav"), extensible = FALSE)
writeWave(cut.cuvieri3, filename = file.path(wav.at, "cut.cuvieri3.wav"), extensible = FALSE)
writeWave(cut.centralis1, filename = file.path(wav.at, "cut.centralis1.wav"), extensible = FALSE)
writeWave(cut.centralis2, filename = file.path(wav.at, "cut.centralis2.wav"), extensible = FALSE)
writeWave(cut.centralis3, filename = file.path(wav.at, "cut.centralis3.wav"), extensible = FALSE)
writeWave(cut.kroyeri1, filename = file.path(wav.at, "cut.kroyeri1.wav"), extensible = FALSE)
writeWave(cut.kroyeri2, filename = file.path(wav.at, "cut.kroyeri2.wav"), extensible = FALSE)
writeWave(cut.kroyeri3, filename = file.path(wav.at, "cut.kroyeri3.wav"), extensible = FALSE)
# Place sounds at beggining of sound window before analysis
align.wave(wav.at = wav.at, wav.to = "Aligned",
time.length = 0.8, time.perc = 0.005, dBlevel = 25)
# Verify alignment using analysis.type = "twoDshape"
eigensound(analysis.type = "twoDshape", wav.at = file.path(wav.at, "Aligned"),
store.at = store.at, flim=c(0, 4), tlim=c(0, 0.8),
plot.exp = TRUE, plot.as = "jpeg", dBlevel = 25)
# Go to folder specified by store.at and check jpeg files created
# Run eigensound function using analysis.type = "threeDshape" on aligned wave files
# Store results as R object
eig.sample <- eigensound(analysis.type="threeDshape", wav.at = file.path(wav.at, "Aligned"),
flim=c(0, 4), tlim=c(0, 0.8), dBlevel=25, plot.exp = FALSE,
x.length=70, y.length = 47, log.scale = TRUE)
wav.at
wav.at <- file.path(base::tempdir(), "eigensound")
if(!dir.exists(wav.at)) dir.create(wav.at)
# Create temporary folder to store results
store.at <- file.path(base::tempdir(), "eigensound-output")
if(!dir.exists(store.at)) dir.create(store.at)
# Cut acoustic units from original Wave
cut.cuvieri <- cutw(cuvieri, f=44100, from=0, to=0.9, output = "Wave")
cut.centralis <- cutw(centralis, f=44100, from=0, to=0.9, output = "Wave")
cut.kroyeri <- cutw(kroyeri, f=44100, from=0.2, to=1.1, output = "Wave")
# Export ".wav" files containing acoustic units and store on previosly created folder
writeWave(cut.cuvieri, filename = file.path(wav.at, "cut.cuvieri.wav"), extensible = FALSE)
writeWave(cut.centralis, filename = file.path(wav.at, "cut.centralis.wav"), extensible = FALSE)
writeWave(cut.kroyeri, filename = file.path(wav.at, "cut.kroyeri.wav"), extensible = FALSE)
\donttest{
# Create 2D spectrograms using analysis.type = "twoDshape"
eigensound(analysis.type = "twoDshape", flim=c(0, 4), tlim=c(0, 0.8),
plot.exp=TRUE, wav.at = wav.at, store.at = store.at)
# Create 3D spectrograms using analysis.type = "threeDshape" and store point coordinates
eig.data <- eigensound(analysis.type = "threeDshape", plot.exp=TRUE,
wav.at = wav.at, store.at = store.at, flim=c(0, 4), tlim=c(0, 0.8))
# As simple as this
threeDspectro(centralis)
threeDspectro(cuvieri)
threeDspectro(kroyeri)
# Controling some arguments
threeDspectro(cuvieri, tlim=c(0, 0.5), flim=c(0, 4))
threeDspectro(cuvieri, tlim=c(0, 0.5), flim=c(0, 4), samp.grid=FALSE)
threeDspectro(cuvieri, tlim=c(0, 0.5), flim=c(0, 4), samp.grid=FALSE, dBlevel=60)
# Try different colors
threeDspectro(cuvieri, color=seewave::reverse.terrain.colors(80),
samp.grid=FALSE, tlim=c(0, 0.5), flim=c(0, 4))
threeDspectro(cuvieri, color=seewave::reverse.cm.colors(80),
samp.grid=FALSE, tlim=c(0, 0.5), flim=c(0, 4))
threeDspectro(cuvieri, color=grDevices::heat.colors(80),
samp.grid=FALSE, tlim=c(0, 0.5), flim=c(0, 4))
# Rotation
threeDspectro(cuvieri, tlim=c(0, 0.5), flim=c(0, 4), rotate.Xaxis=40, rotate.Yaxis=50)
# Export your graph
threeDspectro(cuvieri, plot.exp=TRUE, store.at=tempdir(), tlim=c(0,0.5), flim=c(0,4))
install.packages("EcoHydRology")
?EcoHydRology
??EcoHydRology
?check_built
check_built("C:/R/SoundShape_1.1.9.tar.gz", _R_CHECK_LENGTH_1_LOGIC2_=abort,verbose)
dir()
check_built("C:/R/seewave_2.2.0.zip")
_R_CHECK_LENGTH_1_LOGIC2_=abort,verbose
check_R_CHECK_LENGTH_1_LOGIC2_=abort,verbose
check_built("C:/R/SoundShape_1.1.9.tar.gz", '_R_CHECK_LENGTH_1_LOGIC2_=abort,verbose')
check_built("C:/R/SoundShape_1.1.9.tar.gz", cran='_R_CHECK_LENGTH_1_LOGIC2_=abort,verbose')
check_built("C:/R/SoundShape_1.1.9.tar.gz", build_args='_R_CHECK_LENGTH_1_LOGIC2_=abort,verbose')
check_built("C:/R/SoundShape_1.1.9.tar.gz", build_args_R_CHECK_LENGTH_1_LOGIC2_=abort,verbose)
check_built("C:/R/SoundShape_1.1.9.tar.gz", build_args_R_CHECK_LENGTH_1_LOGIC2_)
Sys.setenv('_R_CHECK_LENGTH_1_LOGIC2_=abort,verbose')
Sys.setenv(_R_CHECK_LENGTH_1_LOGIC2_=abort,verbose)
Sys.setenv('_R_CHECK_LENGTH_1_LOGIC2_'=abort,verbose)
Sys.setenv('_R_CHECK_LENGTH_1_LOGIC2_'='abort,verbose')
?Sys.setenv
# R CMD check
#dir("C:/R", pattern="tar.gz")
check_built("C:/R/SoundShape_1.1.9.tar.gz", run_dont_test=TRUE)
library(roxygen2)
library(devtools)
# Clear environment prior to package
rm(list=ls())
# Define working directory where package will be created
setwd("C:/R")
# R CMD check
#dir("C:/R", pattern="tar.gz")
check_built("C:/R/SoundShape_1.1.9.tar.gz", run_dont_test=TRUE)
# R CMD check
#dir("C:/R", pattern="tar.gz")
check_built("C:/R/SoundShape_1.1.9.tar.gz", run_dont_test=TRUE)
# R CMD check
#dir("C:/R", pattern="tar.gz")
check_built("C:/R/SoundShape_1.1.9.tar.gz")
library(roxygen2)
library(devtools)
#find_rtools()
#devtools::install_github("p-rocha/SoundShape")
# Clear environment prior to package
rm(list=ls())
# Define working directory where package will be created
setwd("C:/R")
# Create folder where package will be stored
#create("SoundShape")
# Process documentation (each function edited manually)
document("C:/R/SoundShape")
# Install package directly
install("C:/R/SoundShape")
# Build package
build("C:/R/SoundShape")
??setenv
library(roxygen2)
library(devtools)
#find_rtools()
#devtools::install_github("p-rocha/SoundShape")
# Clear environment prior to package
rm(list=ls())
# Define working directory where package will be created
setwd("C:/R")
# Create folder where package will be stored
#create("SoundShape")
# Process documentation (each function edited manually)
document("C:/R/SoundShape")
# Install package directly
install("C:/R/SoundShape")
# Build package
build("C:/R/SoundShape")
# R CMD check
#dir("C:/R", pattern="tar.gz")
check_built("C:/R/SoundShape_1.1.9.tar.gz")
library(roxygen2)
library(devtools)
#find_rtools()
#devtools::install_github("p-rocha/SoundShape")
# Clear environment prior to package
rm(list=ls())
# Define working directory where package will be created
setwd("C:/R")
# Create folder where package will be stored
#create("SoundShape")
# Process documentation (each function edited manually)
document("C:/R/SoundShape")
# Install package directly
install("C:/R/SoundShape")
# Build package
build("C:/R/SoundShape")
# R CMD check
#dir("C:/R", pattern="tar.gz")
check_built("C:/R/SoundShape_1.1.9.tar.gz")
library(roxygen2)
library(devtools)
#find_rtools()
#devtools::install_github("p-rocha/SoundShape")
# Clear environment prior to package
rm(list=ls())
# Define working directory where package will be created
setwd("C:/R")
# Create folder where package will be stored
#create("SoundShape")
# Process documentation (each function edited manually)
document("C:/R/SoundShape")
# Install package directly
install("C:/R/SoundShape")
# Build package
build("C:/R/SoundShape")
# R CMD check
#dir("C:/R", pattern="tar.gz")
check_built("C:/R/SoundShape_1.1.9.tar.gz")
library(SoundShape)
library(roxygen2)
library(devtools)
?check_built
#devtools::install_github("p-rocha/SoundShape")
# Clear environment prior to package
rm(list=ls())
# Define working directory where package will be created
setwd("C:/R")
# Create folder where package will be stored
#create("SoundShape")
# Process documentation (each function edited manually)
document("C:/R/SoundShape")
# Install package directly
install("C:/R/SoundShape")
# Build package
build("C:/R/SoundShape")
# R CMD check
#dir("C:/R", pattern="tar.gz")
check_built("C:/R/SoundShape_1.1.9.tar.gz", run_dont_test = TRUE)
#devtools::install_github("p-rocha/SoundShape")
# Clear environment prior to package
rm(list=ls())
# Define working directory where package will be created
setwd("C:/R")
# Create folder where package will be stored
#create("SoundShape")
# Process documentation (each function edited manually)
document("C:/R/SoundShape")
# Install package directly
install("C:/R/SoundShape")
# Build package
build("C:/R/SoundShape")
# R CMD check
#dir("C:/R", pattern="tar.gz")
check_built("C:/R/SoundShape_1.1.9.tar.gz", run_dont_test = TRUE)
#devtools::install_github("p-rocha/SoundShape")
# Clear environment prior to package
rm(list=ls())
# Define working directory where package will be created
setwd("C:/R")
# Create folder where package will be stored
#create("SoundShape")
# Process documentation (each function edited manually)
document("C:/R/SoundShape")
# Install package directly
install("C:/R/SoundShape")
# Build package
build("C:/R/SoundShape")
# R CMD check
#dir("C:/R", pattern="tar.gz")
check_built("C:/R/SoundShape_1.1.9.tar.gz", run_dont_test = TRUE)
library(SoundShape)
library(seewave)
library(tuneR)
library(vegan)
# Set working directory
# Session - Set Working Directory - Choose Directory
setwd("C:/R/Cornell Discussion Group")
data(kroyeri)
# Visualizar sonograma completo
spectro(kroyeri)
# Zoom the acoustic unit
spectro(kroyeri, tlim=c(0.2, 1), flim = c(0, 4))
dev.off() # prevent graphical error
# Select and store acoustic unit
kroyeri.cut <- cutw(kroyeri, from = 0.2, to=1, output="Wave")
####
## 3D spectrogram
threeDspectro(kroyeri.cut)
# Definir limites de frequ?ncia
threeDspectro(kroyeri.cut, flim=c(0, 4))
# Define frequency and time limits using original recording
threeDspectro(kroyeri, tlim=c(0.2, 1), flim = c(0, 4))
# Simplified spectrogram (sampling grid, 3D points)
threeDspectro(kroyeri.cut, flim=c(0, 4), samp.grid = T)
threeDspectro(kroyeri.cut, flim=c(0, 4), samp.grid = T, plot.type = "points")
# Export 3D spectrogram
threeDspectro(kroyeri.cut, flim=c(0, 4), plot.exp = T)
threeDspectro(kroyeri.cut, flim=c(0, 4), plot.exp = T, store.at = getwd())
# Change colors
threeDspectro(kroyeri.cut, flim=c(0, 4), color=seewave::reverse.terrain.colors(80))
threeDspectro(kroyeri.cut, flim=c(0, 4), color=seewave::reverse.cm.colors(80))
threeDspectro(kroyeri.cut, flim=c(0, 4), color=grDevices::heat.colors(80))
# Use help for more
?threeDspectro
# Display full spectrograms
spectro(centralis)
spectro(centralis, flim=c(0,3))
spectro(cuvieri, flim=c(0,2.5))
spectro(kroyeri, flim=c(0,4))
# Create using command lines
getwd()
wav.at <- file.path(getwd(), "Acoustic units")
dir.create(wav.at)
dir()
# create subfolder for outputs
store.at <- file.path(getwd(), "Results")
dir.create(store.at)
dir()
# Select acoustic units
spectro(kroyeri)
kroyeri.cut <- cutw(kroyeri, from = 0.2, to=1, output="Wave")
kroyeri.cut <- cutw(kroyeri, from = 0.2, to=1, output="Wave")
# kroyeri
cut.kro1 <- cutw(kroyeri, from=0.16, to=0.96, output = "Wave")
cut.kro2 <- cutw(kroyeri, from=1.55, to=2.35, output = "Wave")
cut.kro3 <- cutw(kroyeri, from=2.9, to=3.8, output = "Wave")
# cuvieri
cut.cuv1 <- cutw(cuvieri, from=0.05, to=0.45, output = "Wave")
cut.cuv2 <- cutw(cuvieri, from=0.73, to=1.13, output = "Wave")
cut.cuv3 <- cutw(cuvieri, from=1.47, to=1.87, output = "Wave")
# centralis
cut.cent1 <- cutw(centralis, from=0.0, to=0.8, output = "Wave")
cut.cent2 <- cutw(centralis, from=1.08, to=1.78, output = "Wave")
cut.cent3 <- cutw(centralis, from=2.1, to=2.8, output = "Wave")
# One by one
writeWave(cut.cent1, filename = file.path(wav.at, "cut.cent1.wav"), extensible=FALSE)
# Create a loop
list.WAV <- c(cut.cent1, cut.cent2, cut.cent3,
cut.cuv1, cut.cuv2, cut.cuv3,
cut.kro1, cut.kro2, cut.kro3)
list.names <- c("cut.cent1", "cut.cent2", "cut.cent3",
"cut.cuv1", "cut.cuv2", "cut.cuv3",
"cut.kro1", "cut.kro2", "cut.kro3")
for(i in 1:length(list.WAV)){
writeWave(list.WAV[[i]], extensible=FALSE,
filename = file.path(wav.at, paste(list.names[i], ".wav", sep="")))
}
dir()
dir("Acoustic units")
spectro(cut.cent1)
spectro(cut.cuv1)
spectro(cut.kro1)
spectro(cut.cent1, tlim=c(0, 0.8), flim=c(0, 4))
spectro(cut.cuv1, tlim=c(0, 0.8), flim=c(0, 4))
spectro(cut.kro1, tlim=c(0,0.8), flim=c(0, 4))
?eigensound()
eigensound(wav.at = wav.at)
eigensound(wav.at = wav.at)
eigensound(wav.at = wav.at, analysis.type = "twoDshape")
eigensound(wav.at = wav.at, analysis.type = "twoDshape",
tlim=c(0, 0.4))
align.wave()
align.wave(wav.at = wav.at)
dir(wav.at)
file.path(wav.at, "Aligned")
eigensound(wav.at=file.path(wav.at, "Aligned"), store.at=store.at,
analysis.type = "twoDshape")
eigensound(wav.at=file.path(wav.at, "Aligned"), store.at=store.at,
analysis.type = "twoDshape", tlim=c(0, 0.8), flim=c(0, 4))
eigensound(wav.at=file.path(wav.at, "Aligned"), store.at=store.at,
analysis.type = "twoDshape", tlim=c(0, 0.8), flim=c(0, 4), dBlevel = 15)
align.wave(wav.at = wav.at, dBlevel = 15)
eigensound(wav.at=file.path(wav.at, "Aligned"), store.at=store.at,
analysis.type = "twoDshape", tlim=c(0, 0.8), flim=c(0, 4), dBlevel = 15)
eigensound(wav.at=file.path(wav.at, "Aligned"), store.at=store.at,
analysis.type = "threeDshape", tlim=c(0, 0.8), flim=c(0, 4), dBlevel=15)
# Alinhar novamente usando novos valores de dBlevel
align.wave(wav.at = wav.at, dBlevel = 25)
eigensound(wav.at=file.path(wav.at, "Aligned"), store.at=store.at,
analysis.type = "twoDshape", tlim=c(0, 0.8), flim=c(0, 4), dBlevel = 25)
eigensound(wav.at=file.path(wav.at, "Aligned"), store.at=store.at,
analysis.type = "threeDshape", tlim=c(0, 0.8), flim=c(0, 4), dBlevel=25)
eigensound(wav.at=file.path(wav.at, "Aligned"), store.at=store.at,
analysis.type = "twoDshape", tlim=c(0, 0.8), flim=c(0, 4), dBlevel = 15)
s.samp <- spectro(cut.cent1, f=44100, wl=512, ovlp=70,
flim=c(0,4), tlim = c(0,0.8), plot=FALSE)
# y-axis
nrow(s.samp$amp)
# x-axis
ncol(s.samp$amp)
# View semilandmarks and store point coordinates
eig.sample <- eigensound(wav.at=file.path(wav.at, "Aligned"), store.at=store.at,
log.scale=T, analysis.type="threeDshape",tlim=c(0,0.8),flim=c(0,4),
dBlevel=25, x.length = 120, y.length = 40, plot.type = "points")
eigensound(wav.at=file.path(wav.at, "Aligned"), store.at=store.at, log.scale= FALSE,
analysis.type = "threeDshape", tlim=c(0, 0.8), flim=c(0, 4), dBlevel=25)
eig.sample <- eigensound(wav.at=file.path(wav.at, "Aligned"), store.at=store.at,
analysis.type="threeDshape",tlim=c(0,0.8),flim=c(0,4),
x.length= 120, y.length= 40, plot.exp = FALSE)
pca.eig.sample <- prcomp(geomorph::two.d.array(eig.sample))
summary(pca.eig.sample)
screeplot(pca.eig.sample, bstick=TRUE)
dev.off()
screeplot(pca.eig.sample, bstick=TRUE)
screeplot(pca.eig.sample, bstick=TRUE)
screeplot(pca.eig.sample, bstick=TRUE)
summary(pca.eig.sample)
screeplot(pca.eig.sample, bstick=TRUE)
pca.plot(pca.eig.sample)
screeplot(pca.eig.sample, bstick=TRUE)
pca.eig.sample <- prcomp(geomorph::two.d.array(eig.sample))
summary(pca.eig.sample)
screeplot(pca.eig.sample, bstick=TRUE)
# Groups
dimnames(eig.sample)[[3]]
sample.gr <- factor(c(rep("centralis", 3), rep("cuvieri", 3), rep("kroyeri", 3)))
pca.plot(pca.eig.sample, groups = sample.gr)
pca.plot(pca.eig.sample, groups = sample.gr, conv.hulls = sample.gr)
####
## 3D spectrogram
threeDspectro(kroyeri.cut)
dev.off()
####
## 3D spectrogram
threeDspectro(kroyeri.cut)
dev.off()
screeplot(pca.eig.sample, bstick=TRUE)
pca.plot(pca.eig.sample)
# Groups
dimnames(eig.sample)[[3]]
sample.gr <- factor(c(rep("centralis", 3), rep("cuvieri", 3), rep("kroyeri", 3)))
pca.plot(pca.eig.sample, groups = sample.gr)
pca.plot(pca.eig.sample, groups = sample.gr, conv.hulls = sample.gr)
pca.plot(pca.eig.sample, groups = sample.gr, conv.hulls = sample.gr, PCs = c(1,3))
pca.plot(pca.eig.sample, groups = sample.gr, conv.hulls = sample.gr, PCs = c(1,3),
leg.pos = "topleft")
jpeg(width=1300, height=1000, units="px", res=200,
filename=file.path(store.at, "PCA - Plot ordenacao.jpeg"))
pca.plot(pca.eig.sample, groups = sample.gr, conv.hulls = sample.gr, PCs = c(1,3),
leg.pos = "topleft", cex=1.4)
dev.off()
hypo.surf(eig.sample, PC="mean", flim=c(0, 4), tlim=c(0, 0.8),
x.length=120, y.length=40)
hypo.surf(eig.sample, PC="mean", flim=c(0, 4), tlim=c(0, 0.8),
x.length=120, y.length=40, plot.exp=T, store.at = store.at)
hypo.surf(eig.sample, PC=1, flim=c(0, 4), tlim=c(0, 0.8),
x.length=120, y.length=40)
hypo.surf(eig.sample, PC=3, flim=c(0, 4), tlim=c(0, 0.8),
x.length=120, y.length=40)
library(SoundShape)
?align.wave
library(seewave)
library(tuneR)
# Create temporary folder to store ".wav" files
wav.at <- file.path(base::tempdir(), "align.wave")
if(!dir.exists(wav.at)) dir.create(wav.at)
# Create temporary folder to store results
store.at <- file.path(base::tempdir(), "align.wave-output")
if(!dir.exists(store.at)) dir.create(store.at)
# Select acoustic units to be analyzed
data(cuvieri)
spectro(cuvieri, flim = c(0,3)) # Visualize sound data that will be used
# Cut acoustic units from original Wave
cut.cuvieri1 <- cutw(cuvieri, f=44100, from=0, to=0.5, output = "Wave")
cut.cuvieri2 <- cutw(cuvieri, f=44100, from=0.7, to=1.2, output = "Wave")
cut.cuvieri3 <- cutw(cuvieri, f=44100, from=1.4, to=1.9, output = "Wave")
# Export ".wav" files containing selected acoustic units and store on previosly created folder
writeWave(cut.cuvieri1, filename = file.path(wav.at, "cut.cuvieri1.wav"), extensible = FALSE)
writeWave(cut.cuvieri2, filename = file.path(wav.at, "cut.cuvieri2.wav"), extensible = FALSE)
writeWave(cut.cuvieri3, filename = file.path(wav.at, "cut.cuvieri3.wav"), extensible = FALSE)
# Align acoustic units selected at 1% of time lenght
align.wave(wav.at = wav.at, wav.to = "Aligned",
time.length = 0.5, time.perc = 0.01, dBlevel = 25)
# Verify alignment using eigensound function featuring analysis.type = "twoDshape"
eigensound(analysis.type = "twoDshape", wav.at = file.path(wav.at, "Aligned"), store.at = store.at,
flim=c(0, 3), tlim=c(0,0.5), dBlevel = 25, plot.exp = TRUE, plot.as = "jpeg")
store.at
# Create temporary folder to store ".wav" files
wav.at <- file.path(base::tempdir(), "align.wave")
# Create temporary folder to store ".wav" files
wav.at <- file.path(base::tempdir(), "align.wave")
wav.at <- "C:/R/SoundShape data test"
setwd(wav.at)
data(cuvieri)
# Cut acoustic units from original Wave
cut.cuvieri1 <- cutw(cuvieri, f=44100, from=0, to=0.5, output = "Wave")
cut.cuvieri2 <- cutw(cuvieri, f=44100, from=0.7, to=1.2, output = "Wave")
cut.cuvieri3 <- cutw(cuvieri, f=44100, from=1.4, to=1.9, output = "Wave")
spectro(cut.cuvieri1)
spectro(cut.cuvieri1)
spectro(cuvieri)
seewave::spectro(tico)
?seewave::spectro(tico)
dev.off()
spectro(cuvieri)
spectro(cuvieri)
spectro(cut.cuvieri1)
# Cut acoustic units from original Wave
cut.cuvieri1 <- cutw(cuvieri, f=44100, from=0, to=0.5, output = "Wave")
cut.cuvieri2 <- cutw(cuvieri, f=44100, from=0.7, to=1.2, output = "Wave")
cut.cuvieri3 <- cutw(cuvieri, f=44100, from=1.4, to=1.9, output = "Wave")
spectro(cut.cuvieri1)
spectro(cut.cuvieri1)
spectro(cuvieri)
spectro(cut.cuvieri1)
spectro(cut.cuvieri2)
spectro(cut.cuvieri3)
# Export ".wav" files containing selected acoustic units and store on previosly created folder
writeWave(cut.cuvieri1, filename = file.path(wav.at, "cut.cuvieri1.wav"), extensible = FALSE)
writeWave(cut.cuvieri2, filename = file.path(wav.at, "cut.cuvieri2.wav"), extensible = FALSE)
writeWave(cut.cuvieri3, filename = file.path(wav.at, "cut.cuvieri3.wav"), extensible = FALSE)
readWave(file.path(wav.at, "cut.cuvieri3.wav"))
cuv3 <- readWave(file.path(wav.at, "cut.cuvieri3.wav"))
spectro(cuv3)
cuv3 <- readWave(file.path(wav.at, "cut.cuvieri2.wav"))
spectro(cuv3)
cuv3 <- readWave(file.path(wav.at, "cut.cuvieri1.wav"))
spectro(cuv3)
if(is.null(wav.at)) {stop("Use 'wav.at' to specify folder path where '.wav' files are stored")}
wav.to="Aligned"
# Create folder to store aligned calls
if(!dir.exists(file.path(wav.at, wav.to))) dir.create(file.path(wav.at, wav.to))
# Create folder to store aligned calls
if(!dir.exists(file.path(wav.at, wav.to))) dir.create(file.path(wav.at, wav.to))
dir.exists(file.path(wav.at, wav.to))
list.files(wav.at, pattern = ".wav")
warnings()
wav.at <- "C:/R/SoundShape data test"
setwd(wav.at)
data(cuvieri)
spectro(cuvieri)
library(seewave)
library(SoundShape)
data(cuvieri)
spectro(cuvieri)
wav.to="Aligned"
dir.exists(file.path(wav.at, wav.to))
list.files(wav.at, pattern = ".wav")
orig.wav0 <- tuneR::readWave(paste(wav.at,"/", file, sep=""))
file = "cut.cuvieri1.wav"
orig.wav0 = tuneR::readWave(paste(wav.at,"/", file, sep=""))
orig.wav0
spectro(orig)
spectro(orig.wav0)
f=44100
