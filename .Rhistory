dir()
dir("Acoustic units")
spectro(cut.cent1)
spectro(cut.cuv1)
spectro(cut.kro1)
spectro(cut.cent1, tlim=c(0, 0.8), flim=c(0, 4))
spectro(cut.cuv1, tlim=c(0, 0.8), flim=c(0, 4))
spectro(cut.kro1, tlim=c(0,0.8), flim=c(0, 4))
?eigensound()
eigensound(wav.at = wav.at)
eigensound(wav.at = wav.at)
eigensound(wav.at = wav.at, analysis.type = "twoDshape")
eigensound(wav.at = wav.at, analysis.type = "twoDshape",
tlim=c(0, 0.4))
align.wave()
align.wave(wav.at = wav.at)
dir(wav.at)
file.path(wav.at, "Aligned")
eigensound(wav.at=file.path(wav.at, "Aligned"), store.at=store.at,
analysis.type = "twoDshape")
eigensound(wav.at=file.path(wav.at, "Aligned"), store.at=store.at,
analysis.type = "twoDshape", tlim=c(0, 0.8), flim=c(0, 4))
eigensound(wav.at=file.path(wav.at, "Aligned"), store.at=store.at,
analysis.type = "twoDshape", tlim=c(0, 0.8), flim=c(0, 4), dBlevel = 15)
align.wave(wav.at = wav.at, dBlevel = 15)
eigensound(wav.at=file.path(wav.at, "Aligned"), store.at=store.at,
analysis.type = "twoDshape", tlim=c(0, 0.8), flim=c(0, 4), dBlevel = 15)
eigensound(wav.at=file.path(wav.at, "Aligned"), store.at=store.at,
analysis.type = "threeDshape", tlim=c(0, 0.8), flim=c(0, 4), dBlevel=15)
# Alinhar novamente usando novos valores de dBlevel
align.wave(wav.at = wav.at, dBlevel = 25)
eigensound(wav.at=file.path(wav.at, "Aligned"), store.at=store.at,
analysis.type = "twoDshape", tlim=c(0, 0.8), flim=c(0, 4), dBlevel = 25)
eigensound(wav.at=file.path(wav.at, "Aligned"), store.at=store.at,
analysis.type = "threeDshape", tlim=c(0, 0.8), flim=c(0, 4), dBlevel=25)
eigensound(wav.at=file.path(wav.at, "Aligned"), store.at=store.at,
analysis.type = "twoDshape", tlim=c(0, 0.8), flim=c(0, 4), dBlevel = 15)
s.samp <- spectro(cut.cent1, f=44100, wl=512, ovlp=70,
flim=c(0,4), tlim = c(0,0.8), plot=FALSE)
# y-axis
nrow(s.samp$amp)
# x-axis
ncol(s.samp$amp)
# View semilandmarks and store point coordinates
eig.sample <- eigensound(wav.at=file.path(wav.at, "Aligned"), store.at=store.at,
log.scale=T, analysis.type="threeDshape",tlim=c(0,0.8),flim=c(0,4),
dBlevel=25, x.length = 120, y.length = 40, plot.type = "points")
eigensound(wav.at=file.path(wav.at, "Aligned"), store.at=store.at, log.scale= FALSE,
analysis.type = "threeDshape", tlim=c(0, 0.8), flim=c(0, 4), dBlevel=25)
eig.sample <- eigensound(wav.at=file.path(wav.at, "Aligned"), store.at=store.at,
analysis.type="threeDshape",tlim=c(0,0.8),flim=c(0,4),
x.length= 120, y.length= 40, plot.exp = FALSE)
pca.eig.sample <- prcomp(geomorph::two.d.array(eig.sample))
summary(pca.eig.sample)
screeplot(pca.eig.sample, bstick=TRUE)
dev.off()
screeplot(pca.eig.sample, bstick=TRUE)
screeplot(pca.eig.sample, bstick=TRUE)
screeplot(pca.eig.sample, bstick=TRUE)
summary(pca.eig.sample)
screeplot(pca.eig.sample, bstick=TRUE)
pca.plot(pca.eig.sample)
screeplot(pca.eig.sample, bstick=TRUE)
pca.eig.sample <- prcomp(geomorph::two.d.array(eig.sample))
summary(pca.eig.sample)
screeplot(pca.eig.sample, bstick=TRUE)
# Groups
dimnames(eig.sample)[[3]]
sample.gr <- factor(c(rep("centralis", 3), rep("cuvieri", 3), rep("kroyeri", 3)))
pca.plot(pca.eig.sample, groups = sample.gr)
pca.plot(pca.eig.sample, groups = sample.gr, conv.hulls = sample.gr)
####
## 3D spectrogram
threeDspectro(kroyeri.cut)
dev.off()
####
## 3D spectrogram
threeDspectro(kroyeri.cut)
dev.off()
screeplot(pca.eig.sample, bstick=TRUE)
pca.plot(pca.eig.sample)
# Groups
dimnames(eig.sample)[[3]]
sample.gr <- factor(c(rep("centralis", 3), rep("cuvieri", 3), rep("kroyeri", 3)))
pca.plot(pca.eig.sample, groups = sample.gr)
pca.plot(pca.eig.sample, groups = sample.gr, conv.hulls = sample.gr)
pca.plot(pca.eig.sample, groups = sample.gr, conv.hulls = sample.gr, PCs = c(1,3))
pca.plot(pca.eig.sample, groups = sample.gr, conv.hulls = sample.gr, PCs = c(1,3),
leg.pos = "topleft")
jpeg(width=1300, height=1000, units="px", res=200,
filename=file.path(store.at, "PCA - Plot ordenacao.jpeg"))
pca.plot(pca.eig.sample, groups = sample.gr, conv.hulls = sample.gr, PCs = c(1,3),
leg.pos = "topleft", cex=1.4)
dev.off()
hypo.surf(eig.sample, PC="mean", flim=c(0, 4), tlim=c(0, 0.8),
x.length=120, y.length=40)
hypo.surf(eig.sample, PC="mean", flim=c(0, 4), tlim=c(0, 0.8),
x.length=120, y.length=40, plot.exp=T, store.at = store.at)
hypo.surf(eig.sample, PC=1, flim=c(0, 4), tlim=c(0, 0.8),
x.length=120, y.length=40)
hypo.surf(eig.sample, PC=3, flim=c(0, 4), tlim=c(0, 0.8),
x.length=120, y.length=40)
library(SoundShape)
?align.wave
library(seewave)
library(tuneR)
# Create temporary folder to store ".wav" files
wav.at <- file.path(base::tempdir(), "align.wave")
if(!dir.exists(wav.at)) dir.create(wav.at)
# Create temporary folder to store results
store.at <- file.path(base::tempdir(), "align.wave-output")
if(!dir.exists(store.at)) dir.create(store.at)
# Select acoustic units to be analyzed
data(cuvieri)
spectro(cuvieri, flim = c(0,3)) # Visualize sound data that will be used
# Cut acoustic units from original Wave
cut.cuvieri1 <- cutw(cuvieri, f=44100, from=0, to=0.5, output = "Wave")
cut.cuvieri2 <- cutw(cuvieri, f=44100, from=0.7, to=1.2, output = "Wave")
cut.cuvieri3 <- cutw(cuvieri, f=44100, from=1.4, to=1.9, output = "Wave")
# Export ".wav" files containing selected acoustic units and store on previosly created folder
writeWave(cut.cuvieri1, filename = file.path(wav.at, "cut.cuvieri1.wav"), extensible = FALSE)
writeWave(cut.cuvieri2, filename = file.path(wav.at, "cut.cuvieri2.wav"), extensible = FALSE)
writeWave(cut.cuvieri3, filename = file.path(wav.at, "cut.cuvieri3.wav"), extensible = FALSE)
# Align acoustic units selected at 1% of time lenght
align.wave(wav.at = wav.at, wav.to = "Aligned",
time.length = 0.5, time.perc = 0.01, dBlevel = 25)
# Verify alignment using eigensound function featuring analysis.type = "twoDshape"
eigensound(analysis.type = "twoDshape", wav.at = file.path(wav.at, "Aligned"), store.at = store.at,
flim=c(0, 3), tlim=c(0,0.5), dBlevel = 25, plot.exp = TRUE, plot.as = "jpeg")
store.at
# Create temporary folder to store ".wav" files
wav.at <- file.path(base::tempdir(), "align.wave")
# Create temporary folder to store ".wav" files
wav.at <- file.path(base::tempdir(), "align.wave")
wav.at <- "C:/R/SoundShape data test"
setwd(wav.at)
data(cuvieri)
# Cut acoustic units from original Wave
cut.cuvieri1 <- cutw(cuvieri, f=44100, from=0, to=0.5, output = "Wave")
cut.cuvieri2 <- cutw(cuvieri, f=44100, from=0.7, to=1.2, output = "Wave")
cut.cuvieri3 <- cutw(cuvieri, f=44100, from=1.4, to=1.9, output = "Wave")
spectro(cut.cuvieri1)
spectro(cut.cuvieri1)
spectro(cuvieri)
seewave::spectro(tico)
?seewave::spectro(tico)
dev.off()
spectro(cuvieri)
spectro(cuvieri)
spectro(cut.cuvieri1)
# Cut acoustic units from original Wave
cut.cuvieri1 <- cutw(cuvieri, f=44100, from=0, to=0.5, output = "Wave")
cut.cuvieri2 <- cutw(cuvieri, f=44100, from=0.7, to=1.2, output = "Wave")
cut.cuvieri3 <- cutw(cuvieri, f=44100, from=1.4, to=1.9, output = "Wave")
spectro(cut.cuvieri1)
spectro(cut.cuvieri1)
spectro(cuvieri)
spectro(cut.cuvieri1)
spectro(cut.cuvieri2)
spectro(cut.cuvieri3)
# Export ".wav" files containing selected acoustic units and store on previosly created folder
writeWave(cut.cuvieri1, filename = file.path(wav.at, "cut.cuvieri1.wav"), extensible = FALSE)
writeWave(cut.cuvieri2, filename = file.path(wav.at, "cut.cuvieri2.wav"), extensible = FALSE)
writeWave(cut.cuvieri3, filename = file.path(wav.at, "cut.cuvieri3.wav"), extensible = FALSE)
readWave(file.path(wav.at, "cut.cuvieri3.wav"))
cuv3 <- readWave(file.path(wav.at, "cut.cuvieri3.wav"))
spectro(cuv3)
cuv3 <- readWave(file.path(wav.at, "cut.cuvieri2.wav"))
spectro(cuv3)
cuv3 <- readWave(file.path(wav.at, "cut.cuvieri1.wav"))
spectro(cuv3)
if(is.null(wav.at)) {stop("Use 'wav.at' to specify folder path where '.wav' files are stored")}
wav.to="Aligned"
# Create folder to store aligned calls
if(!dir.exists(file.path(wav.at, wav.to))) dir.create(file.path(wav.at, wav.to))
# Create folder to store aligned calls
if(!dir.exists(file.path(wav.at, wav.to))) dir.create(file.path(wav.at, wav.to))
dir.exists(file.path(wav.at, wav.to))
list.files(wav.at, pattern = ".wav")
warnings()
wav.at <- "C:/R/SoundShape data test"
setwd(wav.at)
data(cuvieri)
spectro(cuvieri)
library(seewave)
library(SoundShape)
data(cuvieri)
spectro(cuvieri)
wav.to="Aligned"
dir.exists(file.path(wav.at, wav.to))
list.files(wav.at, pattern = ".wav")
orig.wav0 <- tuneR::readWave(paste(wav.at,"/", file, sep=""))
file = "cut.cuvieri1.wav"
orig.wav0 = tuneR::readWave(paste(wav.at,"/", file, sep=""))
orig.wav0
spectro(orig)
spectro(orig.wav0)
f=44100
library(seewave)
library(SoundShape)
wav.at <- "C:/R/SoundShape data test"
setwd(wav.at)
#align.wave <- function(
wav.at=NULL
wav.to="Aligned"
time.length=1
time.perc=0.005
dBlevel=25
f=44100
wl=512
ovlp=70
file = "cut.cuvieri1.wav"
orig.wav0 = tuneR::readWave(paste(wav.at,"/", file, sep=""))
paste(wav.at,"/", file, sep="")
paste(wav.at)
wav.at()
wav.at
wav.at <- "C:/R/SoundShape data test"
paste(wav.at)
paste(wav.at, "/", file, sep="")
orig.wav0 = tuneR::readWave(paste(wav.at,"/", file, sep=""))
spectro(orig.wav0)
spectro(orig.wav0)
# Add silence to fill sound window and prevent error
orig.wav = seewave::addsilw(orig.wav0, f=f, at="end", d=(time.length*10), output = "Wave")
dev.off()
# Add silence to fill sound window and prevent error
orig.wav = seewave::addsilw(orig.wav0, f=f, at="end", d=(time.length*10), output = "Wave")
spectro(orig.wav)
# create spectro object
orig.spec = seewave::spectro(orig.wav, f=f, wl=wl, ovlp=ovlp, osc=F, grid=F, plot=T)
# create spectro object
orig.spec = seewave::spectro(orig.wav, f=f, wl=wl, ovlp=ovlp, osc=F, grid=F, plot=F)
# Acquire contours
cont.spec <- grDevices::contourLines(x=orig.spec$time, y=orig.spec$freq, z=t(orig.spec$amp),
levels=seq(-dBlevel,-dBlevel,1))
# vectors to store minimum and maximum time values
min.spec <- numeric(length(cont.spec))
max.spec <- numeric(length(cont.spec))
max.spec
min.spec
cont.spec
plot(cont.spec)
plot(cont.spec[1])
plot(cont.spec[[1]])
dev.off()
plot(cont.spec[[1]])
length(cont.spec)
# vectors to store minimum and maximum time values
min.spec = numeric(length(cont.spec))
max.spec = numeric(length(cont.spec))
# minimum and maximum time values among contours detected
for(i in 1:length(min.spec)){min.spec[i] <- min(cont.spec[[i]]$x)}
min.spec
for(i in 1:length(max.spec)){max.spec[i] <- max(cont.spec[[i]]$x)}
plot(min.spec)
plot(max.spec)
# minimum and maximum time values
t.min = min(min.spec)
t.max = max(max.spec)
(t.min-(time.perc*time.length))<=0
# cut Wave file using minimum and maximum time values
short.wav0 <- seewave::deletew(orig.wav, f=f, output = "Wave",
from = (t.max+(time.perc*time.length)), to = max(orig.spec$time))
plot(short.wav0)
spectro(short.wav0)
short.wav = seewave::deletew(short.wav0, f=f, output = "Wave",
from = 0, to = (t.min-(time.perc*time.length)))
spectro(short.wav)
# Add silence to fill sound window
final.wav = seewave::addsilw(short.wav, f=f, at="end", d=time.length, output = "Wave")
spectro(final.wav)
eigensound(analysis.type = "twoDshape", wav.at = file.path(wav.at, "Aligned"), store.at = store.at,
flim=c(0, 3), tlim=c(0,0.5), dBlevel = 25, plot.exp = TRUE, plot.as = "jpeg")
store.at
store.at <- "C:/R/SoundShape data test/align.wave-output"
eigensound(analysis.type = "twoDshape", wav.at = file.path(wav.at, "Aligned"), store.at = store.at,
flim=c(0, 3), tlim=c(0,0.5), dBlevel = 25, plot.exp = TRUE, plot.as = "jpeg")
eigensound(analysis.type = "twoDshape", wav.at = file.path(wav.at, "Aligned"), store.at = wav.at,
flim=c(0, 3), tlim=c(0,0.5), dBlevel = 25, plot.exp = TRUE, plot.as = "jpeg")
wav.at
eigensound(analysis.type = "twoDshape", wav.at = file.path(wav.at, "Aligned"), store.at = wav.at,
flim=c(0, 3), tlim=c(0,0.5), dBlevel = 25, plot.exp = TRUE, plot.as = "jpeg")
align.wave(wav.at = wav.at, wav.to = "Aligned",
time.length = 0.5, time.perc = 0.01, dBlevel = 25)
eigensound(analysis.type = "twoDshape", wav.at = file.path(wav.at, "Aligned"), store.at = wav.at,
flim=c(0, 3), tlim=c(0,0.5), dBlevel = 25, plot.exp = TRUE, plot.as = "jpeg")
wav.at
wav.at = "C:/R/SoundShape data test/Aligned"
dir(wav.at)
store.at
store.at = wav.at
dBlevel=25
flim=c(0, 10)
store.at
list.files(wav.at, pattern = ".wav")
file= list.files(wav.at, pattern = ".wav")[1]
file
threeD <- tuneR::readWave(paste(wav.at,"/", file, sep=""))
spectro(threeD)
flim
dBlevel=25
flim=c(0, 10)
tlim = c(0, 1)
trel=tlim
x.length=80
y.length=60
log.scale=TRUE
back.amp=35
add.points=FALSE
add.contour=TRUE
lwd=1
EQ= c(0.05, 0.15, 0.3, 0.5, 0.7, 0.85, 0.95)
mag.time=1
f=44100
wl=512
ovlp=70
plot.exp = TRUE
plot.as = "jpeg"
plot.type = "surface"
rotate.Xaxis=60
rotate.Yaxis=40
TPS.file = NULL
# Store spectrogram as R object
e <-  seewave::spectro(threeD, f=f, wl=wl, ovlp=ovlp, flim=flim, tlim=tlim, plot=F)
threeD
tlim = c(0, 0.7)
# Store spectrogram as R object
e <-  seewave::spectro(threeD, f=f, wl=wl, ovlp=ovlp, flim=flim, tlim=tlim, plot=F)
e
# Create sequences to use as new grid
freq.seq <- seq(1, length(e$freq), length = y.length)
freq.seq
log.scale
ifelse(isTRUE(log.scale),
time.seq <- 10^(seq(log10(1), log10(length(e$time)), length.out = x.length)),#log
time.seq <- seq(1, length(e$time), length.out = x.length)) # linear scale
time.seq
# Subset original coordinates by new sequences
time.sub <- e$time[time.seq]
freq.sub <- e$freq[freq.seq]
# Subset matrix of amplitude values using new sequences
amp.sub <- e$amp[freq.seq, time.seq]
# Reassign background amplitude values
for(i in 1:length(amp.sub)){if(amp.sub[i] == -Inf |amp.sub[i] <= -dBlevel)
{amp.sub[i] <- -dBlevel}}
# Assign time and frequency coordinates as column and row names of amplitude matrix
colnames(amp.sub) <- time.sub
rownames(amp.sub) <- freq.sub
amp.sub
# Transform amplitude matrix into semilandmark 3D coordinates
ind.3D <- as.matrix(stats::setNames(reshape2::melt(t(amp.sub)), c('time', 'freq', 'amp')))
?seewave::spectro()
?eigensound
seewave
spectro
tlim
dev.off()
tlim
trel
!is.null(tlim) && trel
tlim=NULL
!is.null(tlim) && trel
tlim=c(0.0 0.7)
tlim=c(0.0, 0.7)
tlim
!is.null(tlim) && trel
tlim=c(0.0, 0.7)
trel=NULL
!is.null(tlim) && trel
trel=NULL
!is.null(tlim) && trel
trel=tlim
!is.null(tlim) && trel
tlim=NULL
!is.null(tlim) && trel
tlim=c(0.0, 0.7)
!is.null(tlim) && trel
tlim=NULL
trel=tlim
tlim=c(0.0, 0.7)
!is.null(tlim) && trel
!is.null(tlim)
tlim
trel
!is.null(tlim) && trel
?spectro
#'
#' \itemize{
#'   \item{\code{\link{align.wave}}: Automatic placement of calls at the beggining of a sound window.}
#'   \item{\code{\link{eigensound}}: Calculate spectrogram data for each \code{".wav"} file on a given folder and acquire semilandmarks using a 3D representation of sound.}
#'   \item{\code{\link{pca.plot}}: Plot ordination of Principal Components with convex hulls.}
#'   \item{\code{\link{hypo.surf}}: Hypothetical 3D plots of sound surfaces representing a sample of sounds submited to \code{\link{eigensound}}.}
#'   \item{\code{\link{threeDspectro}}: Colorful 3D spectrograms from a single object of class \code{"Wave"}.}
#' }
#'
#' @name SoundShape
"_PACKAGE"
# Acquire spectrogram data
s <- seewave::spectro(wave, plot=F, f=f, wl=wl, ovlp=ovlp, tlim=tlim, flim=flim)
R.version
library(SoundShape)
library(roxygen2)
library(devtools)
# Clear environment prior to package
rm(list=ls())
# Define working directory where package will be created
setwd("C:/R")
# Process documentation (each function edited manually)
document("C:/R/SoundShape")
# Install package directly
install("C:/R/SoundShape")
dir(pattern = "tar.gz")
# Process documentation (each function edited manually)
document("C:/R/SoundShape")
# Install package directly
install("C:/R/SoundShape")
install.packages(‘magrittr’)
install.packages("magrittr")
install.packages("magrittr")
library(roxygen2)
library(devtools)
# Clear environment prior to package
rm(list=ls())
# Define working directory where package will be created
setwd("C:/R")
# Process documentation (each function edited manually)
document("C:/R/SoundShape")
# Install package directly
install("C:/R/SoundShape")
install.packages("Rcpp")
install.packages("Rcpp")
library(roxygen2)
library(devtools)
#find_rtools()
#devtools::install_github("p-rocha/SoundShape")
# Clear environment prior to package
rm(list=ls())
# Define working directory where package will be created
setwd("C:/R")
# Create folder where package will be stored
#create("SoundShape")
# Process documentation (each function edited manually)
document("C:/R/SoundShape")
# Install package directly
install("C:/R/SoundShape")
library(SoundShape)
SoundShape
version
?`SoundShape-package`
library(roxygen2)
library(devtools)
# Clear environment prior to package
rm(list=ls())
# Define working directory where package will be created
setwd("C:/R")
# Process documentation (each function edited manually)
document("C:/R/SoundShape")
# Install package directly
install("C:/R/SoundShape")
# Build package
build("C:/R/SoundShape")
dir(pattern = "tar.gz")
# R CMD check
#dir("C:/R", pattern="tar.gz")
check_built("C:/R/SoundShape_1.2.1.tar.gz", run_dont_test = TRUE)
version()
version
version
library(roxygen2)
library(devtools)
# Clear environment prior to package
rm(list=ls())
# Define working directory where package will be created
setwd("C:/R")
# R CMD check
#dir("C:/R", pattern="tar.gz")
check_built("C:/R/SoundShape_1.2.1.tar.gz", run_dont_test = TRUE)
find_rtools()
find_rtools()
library(roxygen2)
library(devtools)
find_rtools()
# R CMD check
#dir("C:/R", pattern="tar.gz")
check_built("C:/R/SoundShape_1.2.1.tar.gz", run_dont_test = TRUE)
install.packages("geomorph")
# R CMD check
#dir("C:/R", pattern="tar.gz")
check_built("C:/R/SoundShape_1.2.1.tar.gz", run_dont_test = TRUE)
install.packages("abind")
install.packages("plot3D")
# R CMD check
#dir("C:/R", pattern="tar.gz")
check_built("C:/R/SoundShape_1.2.1.tar.gz", run_dont_test = TRUE)
install.packages("vegan")
install.packages("reshape2")
install.packages("rmarkdown")
# R CMD check
#dir("C:/R", pattern="tar.gz")
check_built("C:/R/SoundShape_1.2.1.tar.gz", run_dont_test = TRUE)
library(roxygen2)
library(devtools)
# Clear environment prior to package
rm(list=ls())
# Define working directory where package will be created
setwd("C:/R")
# Process documentation (each function edited manually)
document("C:/R/SoundShape")
# Install package directly
install("C:/R/SoundShape")
.Last.error
